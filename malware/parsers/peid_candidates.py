#!/usr/bin/env python

import argparse
import json
import logging
import os
import re

import peutils


SUB_REGEXP = re.compile(r".\w+\:([\dA-F]+)\s+.+=\s+S\s+U\s+B\s+R\s+O\s+U\s+T\s+I\s+N\s+E\s+=")
COLLAPSED_FUNCTION = re.compile(r".\w+\:([\dA-F]+)\s+.+COLLAPSED\s+FUNCTION")


def get_offsets(content):
    offsets = {}
    section = None
    for line in content:
        m = re.search(SUB_REGEXP, line)
        if m is not None:
            offsets[int(m.group(1), 16)] = line
        else:
            m = re.search(COLLAPSED_FUNCTION, line)
            if m is not None:
                offsets[int(m.group(1), 16)] = line

    return offsets


def get_bytes(content):
    bts = []
    start = None
    for line in content:
        offset, bts_str = line.rstrip().split(" ", 1)
        bts += map(lambda x: str(chr(int(x.replace("?", "0"), 16))), bts_str.split(" "))
        if start is None:
            start = int(offset, 16)
    return "".join(bts), start


def main():
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument("data_dir")
    arg_parser.add_argument("output")
    args = arg_parser.parse_args()

    signatures = peutils.SignatureDatabase('userdb.txt')

    with open(args.output, "w") as out:
        for filename in os.listdir(args.data_dir):
            if not filename.endswith(".asm"):
                continue
            binary_id = os.path.splitext(os.path.basename(filename))[0]
            asm_filename = os.path.join(args.data_dir, binary_id + ".asm")
            bytes_filename = os.path.join(args.data_dir, binary_id + ".bytes")
            try:
                with open(asm_filename, "r") as inp:
                    content = inp.readlines()
                    offsets = get_offsets(content)
                    with open(bytes_filename, "r") as inp:
                        content = inp.readlines()
                        bts, start = get_bytes(content)
                        CANDIDATE_LENGTH = 200
                        res = {
                            "binary_id": binary_id,
                            "peid": []
                        }
                        for offset in offsets.iterkeys():
                            candidate = bts[(offset - start):(offset - start + CANDIDATE_LENGTH)]
                            matches = signatures.match_data(candidate)
                            if matches:
                                matched_candidate = map(lambda x: ord(x), candidate)
                                res["peid"].append({
                                    "candidate_string": matched_candidate,
                                    "matches": matches,
                                    "place": {
                                        "offset": offset,
                                        "line": offsets[offset]
                                    }
                                })

                        print >>out, json.dumps(res)
            except Exception as err:
                logging.exception(filename)


if __name__ == "__main__":
    main()

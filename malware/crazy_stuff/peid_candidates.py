#!/usr/bin/env python

import argparse
import re

import peutils


SUB_REGEXP = re.compile(r".\w+\:([\dA-F]+)\s+.+=\s+S\s+U\s+B\s+R\s+O\s+U\s+T\s+I\s+N\s+E\s+=")
COLLAPSED_FUNCTION = re.compile(r".\w+\:([\dA-F]+)\s+.+COLLAPSED\s+FUNCTION")


def get_offsets(content):
    offsets = {}
    section = None
    for line in content:
        m = re.search(SUB_REGEXP, line)
        if m is not None:
            offsets[int(m.group(1), 16)] = line
        else:
            m = re.search(COLLAPSED_FUNCTION, line)
            if m is not None:
                offsets[int(m.group(1), 16)] = line

    return offsets


def get_bytes(content):
    bts = []
    start = None
    for line in content:
        offset, bts_str = line.rstrip().split(" ", 1)
        bts += map(lambda x: chr(int(x.replace("?", "0"), 16)), bts_str.split(" "))
        if start is None:
            start = int(offset, 16)
    return "".join(bts), start


def main():
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument("binary_id")
    args = arg_parser.parse_args()

    signatures = peutils.SignatureDatabase('userdb.txt')

    with open("{0}.asm".format(args.binary_id), "r") as inp:
        content = inp.readlines()
        offsets = get_offsets(content)
        with open("{0}.bytes".format(args.binary_id), "r") as inp:
            content = inp.readlines()
            bts, start = get_bytes(content)
            CANDIDATE_LENGTH = 1000
            for offset in offsets.iterkeys():
                candidate = bts[(offset - start):(offset - start + CANDIDATE_LENGTH)]
                matches = signatures.match_data(candidate)
                if matches:
                    print map(lambda x: ord(x), candidate)
                    print offset, offsets[offset]
                    print matches


if __name__ == "__main__":
    main()
